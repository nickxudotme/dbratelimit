> PS：
> AI 写的，还没细看，有空打磨一下
> This project is generated by AI, I haven't looked at it yet, I will polish it when I have time.

# DB Rate Limit

一个为 Go 的 `database/sql` 和 GORM 提供速率限制功能的轻量级包装器。

当你的隔壁部门把他们的 DB 权限给你查一些数据，但是请你们不要打爆，

## 特性

- ✅ 完全兼容标准 `database/sql` 接口
- ✅ 完全兼容 GORM `ConnPool` 接口
- ✅ 基于 token bucket 算法的速率限制
- ✅ 支持上下文取消和超时
- ✅ 并发安全
- ✅ 零依赖（除了 `golang.org/x/time/rate`）

## 安装

```bash
go get github.com/nickxudotme/db-rate-limit
```

## 快速开始

### 与标准 database/sql 使用

```go
package main

import (
    "context"
    "database/sql"
    "log"
    
    "github.com/nickxudotme/dbratelimit"
    _ "github.com/mattn/go-sqlite3"
    "golang.org/x/time/rate"
)

func main() {
    // 1. 创建标准的 SQL 数据库连接
    db, err := sql.Open("sqlite3", "test.db")
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    // 2. 使用 RateLimitedDB 包装数据库
    // 参数：每秒允许 10 个请求，突发容量为 5
    rateLimitedDB := dbratelimit.Wrap(db, rate.Limit(10), 5)
    defer rateLimitedDB.Close()
    
    // 3. 像使用普通数据库一样使用（所有操作都会受到速率限制）
    _, err = rateLimitedDB.ExecContext(context.Background(),
        "INSERT INTO users (name) VALUES (?)", "Alice")
    if err != nil {
        log.Fatal(err)
    }
}
```

### 与 GORM 使用

```go
package main

import (
    "database/sql"
    "log"
    
    "github.com/nickxudotme/dbratelimit"
    _ "github.com/mattn/go-sqlite3"
    "golang.org/x/time/rate"
    "gorm.io/driver/sqlite"
    "gorm.io/gorm"
)

type User struct {
    ID    uint   `gorm:"primaryKey"`
    Name  string `gorm:"not null"`
    Email string `gorm:"not null"`
}

func main() {
    // 1. 创建标准的 SQL 数据库连接
    sqlDB, err := sql.Open("sqlite3", "test.db")
    if err != nil {
        log.Fatal(err)
    }
    defer sqlDB.Close()
    
    // 2. 使用 RateLimitedDB 包装数据库
    rateLimitedDB := dbratelimit.Wrap(sqlDB, rate.Limit(20), 10)
    defer rateLimitedDB.Close()
    
    // 3. 使用 GORM 连接，将 RateLimitedDB 作为 ConnPool
    gormDB, err := gorm.Open(sqlite.Dialector{
        Conn: rateLimitedDB,
    }, &gorm.Config{})
    if err != nil {
        log.Fatal(err)
    }
    
    // 4. 所有 GORM 操作都会受到速率限制
    gormDB.AutoMigrate(&User{})
    
    user := User{Name: "Bob", Email: "bob@example.com"}
    gormDB.Create(&user)
    
    var foundUser User
    gormDB.First(&foundUser, user.ID)
}
```

## API 文档

### Wrap

```go
func Wrap(db *sql.DB, limit rate.Limit, burst int) *RateLimitedDB
```

创建一个带速率限制的数据库包装器。

**参数：**
- `db`: 标准的 `*sql.DB` 实例
- `limit`: 每秒允许的请求数（`rate.Limit` 类型）
- `burst`: 突发容量，允许短时间内超过速率限制的请求数

**示例：**
```go
// 每秒 10 个请求，突发容量 5
rateLimitedDB := dbratelimit.Wrap(db, rate.Limit(10), 5)

// 每秒 100 个请求，突发容量 20
rateLimitedDB := dbratelimit.Wrap(db, rate.Limit(100), 20)

// 每 2 秒 1 个请求
rateLimitedDB := dbratelimit.Wrap(db, rate.Limit(0.5), 1)
```

### 支持的方法

`RateLimitedDB` 实现了以下方法，所有方法都会受到速率限制：

- `QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error)`
- `QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row`
- `ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error)`
- `PrepareContext(ctx context.Context, query string) (*sql.Stmt, error)`
- `Ping() error`
- `Conn(ctx context.Context) (*sql.Conn, error)`
- `Close() error`

### Raw

```go
func (r *RateLimitedDB) Raw() *sql.DB
```

返回原始的 `*sql.DB` 实例，可以用于绕过速率限制的操作。

**示例：**
```go
rateLimitedDB := dbratelimit.Wrap(db, rate.Limit(10), 5)

// 受速率限制的操作
rateLimitedDB.QueryContext(ctx, "SELECT * FROM users")

// 绕过速率限制的操作
rawDB := rateLimitedDB.Raw()
rawDB.QueryContext(ctx, "SELECT * FROM users")
```

## 使用场景

### 1. 保护数据库免受过载

```go
// 限制应用程序对数据库的访问速率
rateLimitedDB := dbratelimit.Wrap(db, rate.Limit(100), 20)
```

### 2. 遵守第三方数据库服务的速率限制

```go
// 某些云数据库服务有速率限制（例如每秒 50 个请求）
rateLimitedDB := dbratelimit.Wrap(db, rate.Limit(45), 10) // 留一些余量
```

### 3. 控制批量操作的速度

```go
rateLimitedDB := dbratelimit.Wrap(db, rate.Limit(10), 5)

// 批量插入会自动受到速率限制
for i := 0; i < 1000; i++ {
    rateLimitedDB.ExecContext(ctx, "INSERT INTO users (name) VALUES (?)", fmt.Sprintf("User%d", i))
}
```

### 4. 使用上下文控制超时

```go
rateLimitedDB := dbratelimit.Wrap(db, rate.Limit(1), 1)

// 设置超时
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

// 如果速率限制导致等待时间超过 5 秒，操作会失败
_, err := rateLimitedDB.QueryContext(ctx, "SELECT * FROM users")
if err != nil {
    // 处理超时错误
}
```

## 测试

运行测试：

```bash
# 运行所有测试
go test -v

# 运行测试并显示覆盖率
go test -v -cover

# 运行测试并检测数据竞争
go test -v -race

# 只运行 GORM 相关测试
go test -v -run TestGorm
```

当前测试覆盖率：**84.2%**

## 工作原理

`RateLimitedDB` 使用 `golang.org/x/time/rate` 包实现的 token bucket 算法：

1. 每个数据库操作在执行前都会调用 `limiter.Wait(ctx)`
2. 如果有可用的 token，操作立即执行
3. 如果没有可用的 token，操作会等待直到有 token 可用或上下文被取消
4. `burst` 参数允许短时间内的突发请求

## 性能考虑

- 速率限制器本身的开销非常小（纳秒级）
- 主要的性能影响来自于等待 token 的时间
- 建议根据实际需求合理设置 `limit` 和 `burst` 参数
- 对于高并发场景，可以适当增加 `burst` 值以减少等待时间

## 许可证

MIT License

## 贡献

欢迎提交 Issue 和 Pull Request！
